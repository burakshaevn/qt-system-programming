# Двухпросмотровый ассемблер

## Описание

Приложение представляет собой **двухпросмотровый ассемблер для перемещаемых программ** с графическим интерфейсом, написанный на C++ с использованием Qt. 

Программа реализует полный цикл создания перемещаемого объектного кода и поддерживает:

- Ввод исходного кода ассемблера
- Настройку таблицы команд (ТКО)
- Выполнение первого прохода ассемблера (создание таблицы символических имен - ТСИ)
- Выполнение второго прохода ассемблера (генерация объектного кода)
- **Создание таблицы настройки (перемещений)** для поддержки загрузки программы по любому адресу
- Поддержку **прямой адресации** с автоматическим добавлением адресов в таблицу настройки
- Поддержку **относительной адресации** с формированием смещений
- Отображение ошибок компиляции и детальной информации о процессе трансляции

> [!IMPORTANT] 
> **Ассемблер для перемещаемых программ** — это программа, которая преобразует исходную программу на языке ассемблера в перемещаемый объектный модуль. Это позволяет **размещать программу в различных частях памяти без изменения команд** (подробнее см. ниже в «Особенности реализации перемещаемых программ»).

## Структура проекта

```
QtAssembler/
├── CMakeLists.txt          # Файл сборки CMake
├── README.md               # Этот файл
├── include/                # Заголовочные файлы
│   ├── ui/
│   │   └── mainwindow.h
│   ├── assembler/
│   │   └── assembler.h
│   ├── parser/
│   │   └── parser.h
│   ├── structures/
│   │   ├── command.h
│   │   ├── operand.h
│   │   ├── symbolicname.h
│   │   └── codeline.h
│   └── exceptions/
│       └── assemblerexception.h
├── src/                    # Исходные файлы
│   ├── main.cpp
│   ├── ui/
│   │   └── mainwindow.cpp
│   ├── assembler/
│   │   └── assembler.cpp
│   ├── parser/
│   │   └── parser.cpp
│   ├── structures/
│   │   ├── command.cpp
│   │   ├── operand.cpp
│   │   ├── symbolicname.cpp
│   │   └── codeline.cpp
│   └── exceptions/
│       └── assemblerexception.cpp
└── ui/                     # UI файлы Qt Designer
    └── mainwindow.ui
```

## Требования

- Qt 5.15 или выше
- CMake 3.16 или выше
- C++17

## Сборка

Можно собрать через Qt Creator.

## Использование

1. Запустите приложение
2. Введите исходный код ассемблера в левую панель (источник)
3. Настройте таблицу команд (ТКО) - по умолчанию загружены стандартные команды
4. Задайте адрес загрузки программы
5. Нажмите "Первый проход" для выполнения первого прохода ассемблера (создается ТСИ)
6. Нажмите "Второй проход" для генерации объектного кода и таблицы настройки

## Особенности реализации перемещаемых программ

### Таблица настройки (перемещений)

Ассемблер автоматически формирует **таблицу настройки** - список адресов команд, операнды которых должны корректироваться при загрузке программы по адресу, отличному от исходного.

### Режимы адресации

**1. Прямая адресация**
- Операнд содержит абсолютный адрес в памяти
- Адрес команды автоматически добавляется в таблицу настройки
- При загрузке программы по другому адресу операнд будет скорректирован

Пример:
```
LOADR1  LABEL    ; Прямая адресация - адрес LABEL будет в таблице настройки
```

**2. Относительная адресация**
- Операнд содержит смещение относительно текущей команды
- Адрес НЕ добавляется в таблицу настройки (смещение не зависит от адреса загрузки)
- Обозначается префиксом `@`

Пример:
```
JMP  @LABEL      ; Относительная адресация - вычисляется смещение
```

**3. Смешанный режим**
- В одной программе могут использоваться оба режима адресации
- Ассемблер автоматически определяет тип адресации и формирует соответствующий код

## Поддерживаемые директивы

- `START` - начало программы
- `END` - конец программы
- `WORD` - определение слова (3 байта)
- `BYTE` - определение байта или строки
- `RESW` - резервирование слов
- `RESB` - резервирование байтов

## Поддерживаемые команды

По умолчанию поддерживаются следующие команды:

- `JMP` (код 1, длина 4) - безусловный переход
- `LOADR1` (код 2, длина 4) - загрузка в регистр R1
- `LOADR2` (код 3, длина 4) - загрузка в регистр R2
- `ADD` (код 4, длина 2) - сложение
- `SAVER1` (код 5, длина 4) - сохранение регистра R1
- `INT` (код 6, длина 2) - прерывание

## Формат команд

Команды задаются в формате: `ИМЯ КОД ДЛИНА`, где:
- ИМЯ - название команды (латинские буквы и цифры)
- КОД - шестнадцатеричный код команды (0-FF)
- ДЛИНА - длина команды в байтах (1, 2 или 4)

## Примеры исходного кода

### Пример 1: Прямая адресация
```
PROG  START   100
    JMP     L1 
B1  WORD    40 
B3  BYTE    C"Hello!"
B4  BYTE    12	
L1  LOADR1  B1	
    LOADR2  B4
    ADD
    SAVER1  B1
    INT     200	
    END
```
В этом примере все адреса (L1, B1, B4) используют прямую адресацию и будут добавлены в таблицу настройки.

### Пример 2: Относительная адресация
```
PROG  START   100
    JMP     @L1 
B1  WORD    40 
L1  LOADR1  @B1	
    INT     200	
    END
```
В этом примере используется относительная адресация (префикс @), смещения вычисляются автоматически.

### Пример 3: Смешанный режим
```
PROG  START   100
    JMP     @L1      ; Относительная адресация
B1  WORD    40 
L1  LOADR1  B1       ; Прямая адресация
    SAVER1  B1       ; Прямая адресация
    INT     200	
    END
```
В этом примере JMP использует относительную адресацию, а LOADR1 и SAVER1 - прямую.

## Детальное описание структуры кода

### Архитектура

#### 1. **Структуры данных** (`include/structures/`, `src/structures/`)

**Command** (`command.h/cpp`)
- Представляет команду ассемблера
- Содержит: имя команды, код операции, длину в байтах
- Валидация: имя должно начинаться с буквы, код 0-255, длина 1/2/4 байта
- Методы: `getName()`, `getCode()`, `getLength()`, `isValid()`

**Operand** (`operand.h/cpp`)
- Представляет операнд команды
- Использует `std::variant<std::string, int>` для хранения значения
- Методы: `getStringValue()`, `getIntValue()`, `isString()`, `isInt()`

**SymbolicName** (`symbolicname.h/cpp`)
- Представляет символическое имя (метку) в таблице символов
- Содержит: имя метки и её адрес
- Методы: `getName()`, `getAddress()`, `setName()`, `setAddress()`

**CodeLine** (`codeline.h/cpp`)
- Представляет строку исходного кода
- Содержит: метку (опционально), команду, первый операнд (опционально), второй операнд (опционально)
- Методы: `hasLabel()`, `hasFirstOperand()`, `hasSecondOperand()`

#### 2. **Парсер** (`include/parser/`, `src/parser/`)

**Parser** (`parser.h/cpp`)
- Статический класс для парсинга исходного кода
- **`parseCode()`** - разбивает текст на токены с помощью регулярных выражений
- **`textToCommands()`** - парсит таблицу команд из текста
- **`parseCodeLine()`** - парсит строку кода в структуру CodeLine
- **`parseFirstPassLine()`** - парсит результат первого прохода
- **`isCommandOrDirective()`** - определяет, является ли токен командой или директивой

#### 3. **Ассемблер** (`include/assembler/`, `src/assembler/`)

**Assembler** (`assembler.h/cpp`) - основной класс двухпросмотрового ассемблера

**Первый проход** (`firstPass()`):
- Создает таблицу символических имен (TSI)
- Обрабатывает директивы: START, END, WORD, BYTE, RESW, RESB
- Валидирует команды и операнды
- Проверяет переполнение памяти
- Генерирует промежуточный код с адресами

**Второй проход** (`secondPass()`):
- Разрешает символические ссылки
- Генерирует объектный код
- Создает записи H (Header), T (Text), E (End)
- **Формирует таблицу настройки (перемещений)** для прямой адресации
- **Вычисляет смещения** для относительной адресации
- Различает режимы адресации по префиксу @ (относительная адресация)

**Методы обработки директив:**
- `processStartDirective()` - устанавливает начальный адрес
- `processWordDirective()` - резервирует 3 байта для слова
- `processByteDirective()` - резервирует байт или строку
- `processReswDirective()` - резервирует слова
- `processResbDirective()` - резервирует байты
- `processEndDirective()` - устанавливает точку входа

**Вспомогательные методы:**
- `isCommand()`, `isDirective()`, `isLabel()` - проверка типов токенов
- `isRegister()` - проверка регистров R1-R16
- `isCString()`, `isXString()` - проверка строковых констант
- `overflowCheck()` - проверка переполнения памяти
- `convertToASCII()` - преобразование строки в ASCII hex

#### 4. **Пользовательский интерфейс** (`include/ui/`, `src/ui/`)

**MainWindow** (`mainwindow.h/cpp`)
- Главное окно приложения
- Использует UI файл `mainwindow.ui` для интерфейса
- **`onFirstPassClicked()`** - обработчик кнопки первого прохода
- **`onSecondPassClicked()`** - обработчик кнопки второго прохода
- **`initializeDefaultContent()`** - инициализация содержимого по умолчанию

**UI элементы:**
- `sourceCodeTextEdit` - ввод исходного кода
- `commandsTextEdit` - таблица команд
- `firstPassTextEdit` - результат первого прохода
- `tsiTextEdit` - таблица символических имен
- `firstPassErrorsTextEdit` - ошибки первого прохода
- `secondPassTextEdit` - результат второго прохода
- `secondPassErrorsTextEdit` - ошибки второго прохода
- `firstPassButton` - кнопка первого прохода
- `secondPassButton` - кнопка второго прохода

#### 5. **Исключения** (`include/exceptions/`, `src/exceptions/`)

**AssemblerException** (`assemblerexception.h/cpp`)
- Наследуется от `std::runtime_error`
- Используется для всех ошибок ассемблера
- Конструкторы: по умолчанию, с сообщением, с сообщением и внутренним исключением

#### 6. **Точка входа** (`src/main.cpp`)

**main()**
- Создает QApplication
- Создает и показывает MainWindow
- Запускает цикл обработки событий Qt

### Алгоритм работы ассемблера

#### Первый проход:
1. **Инициализация**: очистка TSI, установка ip=0
2. **Парсинг строк**: разбор исходного кода на токены
3. **Обработка меток**: добавление в TSI с текущим адресом
4. **Обработка директив**:
   - START: установка начального адреса
   - WORD: резервирование 3 байт
   - BYTE: резервирование байта/строки
   - RESW/RESB: резервирование памяти
   - END: установка точки входа
5. **Обработка команд**: генерация кода с адресами
6. **Валидация**: проверка ошибок и переполнения

#### Второй проход:
1. **Парсинг первого прохода**: разбор промежуточного кода
2. **Генерация заголовка**: создание H-записи
3. **Обработка команд**: 
   - Разрешение символических ссылок
   - Определение режима адресации (прямая или относительная)
   - Для прямой адресации: добавление адреса в таблицу настройки
   - Для относительной адресации (@): вычисление смещения
4. **Генерация объектного кода**: создание T-записей
5. **Формирование таблицы настройки**: список адресов для корректировки при загрузке
6. **Завершение**: создание E-записи

### Ключевые особенности реализации

- **Двухпросмотровая архитектура**: первый проход создает TSI, второй генерирует код
- **Поддержка перемещаемых программ**: генерация таблицы настройки для загрузки по произвольному адресу
- **Два режима адресации**:
  - Прямая адресация: абсолютные адреса с записью в таблицу настройки
  - Относительная адресация: смещения относительно текущей команды (префикс @)
- **Валидация на каждом этапе**: проверка синтаксиса, семантики, переполнения
- **Поддержка всех типов операндов**: числа, метки, регистры, строки
- **Гибкая система команд**: настраиваемая таблица команд
- **Обработка ошибок**: детальные сообщения об ошибках
- **Графический интерфейс**: удобное отображение всех этапов трансляции (ТКО, ТСИ, таблица настройки, объектный код)
